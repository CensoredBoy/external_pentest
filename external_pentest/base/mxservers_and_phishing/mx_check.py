import os
import socket
import re
import argparse
import logging
import datetime
from functools import reduce
from logging.handlers import WatchedFileHandler
from collections import namedtuple
from ipaddress import ip_address
from subprocess import check_output
from typing import List

from ..models import Scan, Domain, MailReport
import smtplib
import dns.resolver
from colorlog import ColoredFormatter

from .sendemail import sendemail
from .mx_servers_parse import MXServers

#######################################################################################################################
def MXServerTester_setup_logger(log_file, logger_name):
    # users_log_lvl = {"critical": logging.CRITICAL, "error": logging.ERROR, "warning": logging.WARNING, "info": logging.INFO, "debug": logging.DEBUG}[log_level]

    logger = logging.getLogger(logger_name)
    logger.setLevel(logging.DEBUG)

    fmtr = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'

    log_path = os.path.join(os.getcwd(), log_file)
    if not os.path.exists(os.path.dirname(log_path)):
        os.makedirs(os.path.dirname(log_path))
    fh = WatchedFileHandler(log_path)
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(logging.Formatter(fmtr))

    sh = logging.StreamHandler()
    sh.setLevel(logging.DEBUG)
    sh.setFormatter(ColoredFormatter("%(asctime)s - %(name)s - %(log_color)s%(levelname)-8s%(reset)s %(blue)s%(message)s", log_colors={
		'DEBUG':    'cyan',
		'INFO':     'green',
		'WARNING':  'yellow',
		'ERROR':    'red',
        'CRITICAL': 'white,bg_black'
    }))

    logger.addHandler(fh)
    logger.addHandler(sh)
    logger.debug("start")

    return logger

#######################################################################################################################
class MXTesterModes():

    def __init__(self, lang, aii, aci, acc, aicSD, aicSN, aicND, aicSS, aicSC):
        self.lang = lang
        self.aii = aii
        self.aci = aci
        self.acc = acc
        self.aicSD = aicSD
        self.aicSN = aicSN
        self.aicND = aicND
        self.aicSS = aicSS
        self.aicSC = aicSC

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
class MXServerTester():

    LOGGER_NAME = "MXServerTester"

    ###################################################################################################################
    def __init__(self, config, modes, ipv6):

        self.logger = logging.getLogger(MXServerTester.LOGGER_NAME)

        self.mx_servers = None
        self.ipv6 = ipv6
        self.modes = modes
        self.config = config

    ###################################################################################################################
    def _load_config(self, config_file):

        self.logger.debug("Loading config")

        try:
            with open(config_file, 'r') as fin:
                config = yaml.load(fin, Loader=yaml.FullLoader)

        except yaml.YAMLError as exc:
            self.logger.critical("Error parsing configuration file.")
            raise exc

        return config

    ###################################################################################################################
    def check_domain_configurations(self):

        self.logger.debug("Checking SPF,DKIM,DMARC,ADSP records for target domains.")

        for domain in self.config["DOMAINS"]:
            for rtype, rsubdomain, rfilter in [
                ("SPF",                         "",                     "v=spf"),
                ("DKIM (mx)  ",                 "mx._domainkey.",       "v=DKIM"),
                ("DKIM (mail)",                 "mail._domainkey.",     "v=DKIM"),
                ("DKIM (mx01)",                 "mx01._domainkey.",     "v=DKIM"),
                ("DMARC",                       "_dmarc.",              "v=DMARC"),
                ("ADSP (obsolete mechanism)",   "_adsp._domainkey.",    "dkim=")]:

                scan_inst = Scan.objects.get(pk=self.config["SCAN_ID"])
                domain_inst = Domain.objects.filter(domain=domain, scan=scan_inst)[0]
                try:
                    txt_records = dns.resolver.query(rsubdomain + domain, "TXT")
                    matched_records = list(filter(lambda rec: rfilter in rec.to_text(), txt_records))
                    if matched_records:
                        for record in matched_records:
                            report = f"{domain} - {rtype} record found: {record.to_text()[1:-1]}"
                            self.logger.info(report)
                            report_inst = MailReport(scan=scan_inst, mail_domain=domain_inst, report=report)
                    else:
                        report = f"{domain} - {rtype} record NOT found"
                        self.logger.warning(f"{domain} - {rtype} record NOT found")
                        report_inst = MailReport(scan=scan_inst, mail_domain=domain_inst, report=report)

                except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer) as exc:
                    report = f"{domain} - {rtype} record resolv failed."
                    self.logger.warning(f"{domain} - {rtype} record resolv failed.")
                    report_inst = MailReport(scan=scan_inst, mail_domain=domain_inst, report=report)

                report_inst.save()

    ###################################################################################################################
    def smtp_enum_check(self):

        if not self.mx_servers:
            self.mx_servers = MXServers(self.config["DOMAINS"], self.config["MAIL_SERVERS"], self.ipv6)

        self.logger.debug("Performing user enumeration tests.")
        if not self.config["CLIENT_EMAILS"]:
            raise Exception("Testing email servers for user enumerations requires at least one client email in configuration.")

        users_file_name = "users.txt"
        with open(users_file_name, "w") as fusers:
            for email in self.config["CLIENT_EMAILS"]:
                fusers.write(f"{email}\n")
            fusers.write(f'non-existent-email@{self.config["DOMAINS"][0]}\n')

        for name, ip, port in self.mx_servers:
            for method in ["VRFY", "EXPN", "RCPT"]:
                output = check_output(["smtp-user-enum", "-M", method, "-U", "./users.txt", "-t", ip.compressed, "-p", str(port)])
                if "0 results." in output.decode():
                    self.logger.info(f"SMTP server {ip}:{port} appears to be NOT vulnerable to {method} method.")
                else:
                    self.logger.warning(f"SMTP server {ip}:{port} appears to be VULNERABLE to {method} method, further investigation required!")

        os.remove(users_file_name)

    ###################################################################################################################
    def test_email_relays(self):

        if not self.mx_servers:
            self.mx_servers = MXServers(self.config["DOMAINS"], self.config["MAIL_SERVERS"], self.ipv6)

        self.logger.debug("Check relaying capabilities for specified modes (trying to send emails).")

        vectors_for_testing = []

        if self.modes.aci:
            if not self.config["CLIENT_EMAILS"] or not self.config["ATTACKER_EMAILS"]:
                raise Exception("'aci' test requires at least one client email and attacker email specified in configuration.")
            for from_email in self.config["CLIENT_EMAILS"]:
                for to_email in self.config["ATTACKER_EMAILS"]:
                    for name, ip, port in self.mx_servers:
                        vectors_for_testing.append((ip, port, from_email, to_email))

        if self.modes.aii:
            if not self.config["ATTACKER_EMAILS"]:
                raise Exception("'aii' test requires at least one attacker email specified in configuration.")
            for from_email in self.config["ATTACKER_EMAILS"]:
                for to_email in self.config["ATTACKER_EMAILS"]:
                    for name, ip, port in self.mx_servers:
                        vectors_for_testing.append((ip, port, from_email, to_email))

        if self.modes.acc:
            if not self.config["CLIENT_EMAILS"]:
                raise Exception("'acc' test requires at least one attacker email specified in configuration.")
            for from_email in self.config["CLIENT_EMAILS"]:
                for to_email in self.config["CLIENT_EMAILS"]:
                    for name, ip, port in self.mx_servers:
                        vectors_for_testing.append((ip, port, from_email, to_email))

        socket.setdefaulttimeout(20)
        for i in range(3):
            vectors_for_testing = filter(lambda tup: not self._test_relaying_vector(*tup), vectors_for_testing)
        socket.setdefaulttimeout(None)

        for server, port, from_email, to_email in vectors_for_testing:
            self.logger.error(f"Error performing email relaying test for {server.compressed:<15}:{port:<4}, from {from_email:<30} to {to_email:<30}.")

    ###################################################################################################################
    # return False is there is connection errors
    #
    def _test_relaying_vector(self, ip, port, from_email, to_email):
        subject = "Penetration test check."
        email_text = """
        Hello,
        This is a check of your email server in the context of penetration testing, conducted by INFORMZASHCHITA.
        If you have got this email, please forward it to your contact at '...@infosec.ru'.

        With best regards.
        JSC SEE INFORMZASHCHITA
        """ if self.modes.lang == "en" else """
        Добрый день,
        Данное письмо было отправлено с целью проверки вашего mail сервера в рамках тестирования на проникновение, проводимого компанией ИнформЗащита.
        Если данное письмо дошло до вас, пожалуйста перешлите его вашему контакту в ИнформЗащите по адресу '...@infosec.ru'.

        С уважением,
        АО НИП "ИнформЗащита"
        """

        with open("./email-templates/email-html-outlook-template.html") as fin:
            html_template = fin.read()
        email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))

        try:
            sendemail(ip, port, from_email, [to_email], subject, email_text, email_html)
            self.logger.warning(f"Server {ip.compressed:<15}:{port:<4}, from `{from_email:<30}` to `{to_email:<30}`, no error, VULNERABILITY ?")
        except smtplib.SMTPResponseException as exc:
            self.logger.info(f"Server {ip.compressed:<15}:{port:<4}, from `{from_email:<30}` to `{to_email:<30}`, err: `{exc.smtp_code}` - `{exc.smtp_error}`")
        except smtplib.SMTPRecipientsRefused as exc:
            self.logger.info(f"Server {ip.compressed:<15}:{port:<4}, from `{from_email:<30}` to `{to_email:<30}`, err: `{exc}`")

        except (ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
            return False
        return True

    ###################################################################################################################
    def test_email_spoofing(self):

        if not self.mx_servers:
            self.mx_servers = MXServers(self.config["DOMAINS"], self.config["MAIL_SERVERS"], self.ipv6)

        if not self.config['CLIENT_EMAILS'] or not self.config['SPOOFED_FROM'] or not self.config['SPOOF_RET_ADDR'] or not self.config['SPOOFED_BY'] or not self.config['DKIM_DOMAIN'] or not self.config['DKIM_SELECTOR'] or not self.config['DKIM_KEY']:
            raise Exception('No all parameters in configuration file specified. Required fields: CLIENT_EMAILS, SPOOF_RET_ADDR, SPOOFED_FROM and basic spoofing configuration options.')

        with open("./email-templates/email-html-outlook-template.html") as fin:
            html_template = fin.read()
        with open(f"./email-templates/email-spoofing-and-DKIM.{self.modes.lang}.txt", 'r') as fin:
            email_template = fin.read()
        subject = "Antispam system analysis" if self.modes.lang == "en" else "Анализ антиспам системы"

        for name, ip, port in self.mx_servers:
            for to_addr in self.config["CLIENT_EMAILS"]:
                email_template = email_template.replace("{RET_ADDR}", self.config['SPOOF_RET_ADDR']).replace("{MX_SERVER}", f"{ip}:{port}")

                # with spoofing and DKIM
                if self.modes.aicSD:
                    from_addr = f"{self.config['SPOOFED_FROM']} <{self.config['SPOOFED_BY']}>"
                    from_addr_encoded = from_addr.replace("<", "^").replace(">", "^")

                    email_text = email_template.replace("{Spoofed}", "yes").replace("{DKIM}", "yes").replace("{From}", from_addr_encoded).replace("{To}", to_addr)
                    email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))
                    try:
                        sendemail(ip, port,
                            self.config['SPOOFED_BY'], [to_addr], subject, email_text, email_html,
                            additional_headers = {
                                'From': from_addr,
                                'Reply-To': self.config['SPOOF_RET_ADDR'],
                                'Resent-Sender': self.config['SPOOFED_BY'] # bypass RFC4407 (PRA) # 550 - '5.7.1 Missing purported responsible address'
                            },
                            dkim_domain=self.config["DKIM_DOMAIN"],
                            dkim_selector=self.config["DKIM_SELECTOR"],
                            dkim_private_key=self.config["DKIM_KEY"]
                        )
                        self.logger.info(f"(check on client-side) Email with SPOOFING and DKIM has been sent to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}'")
                    except smtplib.SMTPResponseException as exc:
                        self.logger.error(f"Error sending email with SPOOFING and DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc.smtp_code}` - `{exc.smtp_error}`")
                    except (smtplib.SMTPRecipientsRefused, ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
                        self.logger.error(f"Error sending email with SPOOFING and DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc}`")

                # with spoofing and NO DKIM
                if self.modes.aicSN:
                    from_addr = f"{self.config['SPOOFED_FROM']} <{self.config['SPOOFED_BY']}>"
                    from_addr_encoded = from_addr.replace("<", "^").replace(">", "^")

                    email_text = email_template.replace("{Spoofed}", "yes").replace("{DKIM}", "no").replace("{From}", from_addr_encoded).replace("{To}", to_addr)
                    email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))
                    try:
                        sendemail(ip, port,
                            self.config['SPOOFED_BY'], [to_addr], subject, email_text, email_html,
                            additional_headers = {
                                'From': from_addr,
                                'Reply-To': self.config['SPOOF_RET_ADDR'],
                                'Resent-Sender': self.config['SPOOFED_BY'] # bypass RFC4407 (PRA) # 550 - '5.7.1 Missing purported responsible address'
                            }
                        )
                        self.logger.info(f"(check on client-side) Email with SPOOFING and NO DKIM has been sent to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}'")
                    except smtplib.SMTPResponseException as exc:
                        self.logger.error(f"Error sending email with SPOOFING and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc.smtp_code}` - `{exc.smtp_error}`")
                    except (smtplib.SMTPRecipientsRefused, ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
                        self.logger.error(f"Error sending email with SPOOFING and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc}`")

                # with spoofing via subdomain and NO DKIM
                if self.modes.aicSS:
                    from_addr = self.config['SPOOFED_FROM'].replace('@', '@rand-sub.')
                    from_addr_encoded = from_addr.replace("<", "^").replace(">", "^")

                    email_text = email_template.replace("{Spoofed}", "via subdomain").replace("{DKIM}", "no").replace("{From}", from_addr_encoded).replace("{To}", to_addr)
                    email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))
                    try:
                        sendemail(ip, port,
                            self.config['SPOOFED_BY'], [to_addr], subject, email_text, email_html,
                            additional_headers = {
                                'From': from_addr,
                                'Reply-To': self.config['SPOOF_RET_ADDR'],
                                'Resent-Sender': self.config['SPOOFED_BY'] # bypass RFC4407 (PRA) # 550 - '5.7.1 Missing purported responsible address'
                            }
                        )
                        self.logger.info(f"(check on client-side) Email with SPOOFING via SUBDOMAIN and NO DKIM has been sent to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}'")
                    except smtplib.SMTPResponseException as exc:
                        self.logger.error(f"Error sending email with SPOOFING via SUBDOMAIN and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc.smtp_code}` - `{exc.smtp_error}`")
                    except (smtplib.SMTPRecipientsRefused, ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
                        self.logger.error(f"Error sending email with SPOOFING via SUBDOMAIN and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc}`")

                # with poor spoofing and DKIM
                if self.modes.aicND:
                    from_addr = re.sub(r"\S*@\S*", f"<{self.config['SPOOFED_BY']}>", self.config['SPOOFED_FROM'])
                    from_addr_encoded = from_addr.replace("<", "^").replace(">", "^")

                    email_text = email_template.replace("{Spoofed}", "name only").replace("{DKIM}", "yes").replace("{From}", from_addr_encoded).replace("{To}", to_addr)
                    email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))
                    try:
                        sendemail(ip, port,
                            self.config['SPOOFED_BY'], [to_addr], subject, email_text, email_html,
                            additional_headers = {
                                'From': from_addr,
                                'Reply-To': self.config['SPOOF_RET_ADDR'],
                                'Resent-Sender': self.config['SPOOFED_BY'] # bypass RFC4407 (PRA) # 550 - '5.7.1 Missing purported responsible address'
                            },
                            dkim_domain=self.config["DKIM_DOMAIN"],
                            dkim_selector=self.config["DKIM_SELECTOR"],
                            dkim_private_key=self.config["DKIM_KEY"]
                        )
                        self.logger.info(f"(check on client-side) Email with Partial SPOOFING and DKIM has been sent to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}'")
                    except smtplib.SMTPResponseException as exc:
                        self.logger.error(f"Error sending email with Partial SPOOFING and DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc.smtp_code}` - `{exc.smtp_error}`")
                    except (smtplib.SMTPRecipientsRefused, ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
                        self.logger.error(f"Error sending email with Partial SPOOFING and DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc}`")

                # with spoofing via special chars in subdomain
                if self.modes.aicSC:

                    # left the most dangerous chars (all chars usually pose a risk)
                    pwn_dict = {
                        chr(0): 'Null byte', # infosec outlook - vuln
                        #chr(10): 'New line',
                        #chr(11): 'Vertical tab',
                        #chr(12): 'Form feed',
                        #chr(13): 'Carriage ret',
                        #chr(28): 'File separator',
                        #chr(29): 'Group separator',
                        #chr(30): 'Record separator',
                        chr(40): 'Bracket (' # infosec outlook - vuln
                    }

                    for char in pwn_dict:
                        from_addr = self.config['SPOOFED_FROM'].replace('@', '@'+self.config['SPOOFED_FROM'].split('@')[1] + char + '.test.').replace('>', '') + '>'
                        from_addr_encoded = from_addr.replace("<", "^").replace(">", "^")

                        email_text = email_template.replace("{Spoofed}", "via special chars with " + pwn_dict[char]).replace("{DKIM}", "no").replace("{From}", from_addr_encoded).replace("{To}", to_addr)
                        email_html = html_template.replace("{TEXT}", email_text.replace('\n', '<br>'))
                        try:
                            sendemail(ip, port, re.search(r'[a-zA-Z0-9-_.]+@[a-zA-Z0-9-_.]{1,}', self.config['SPOOFED_FROM'].replace('@', '@test.')).group(), [to_addr], subject, email_text, email_html,
                                    additional_headers = {'From': from_addr})
                            self.logger.info(f"(check on client-side) Email with SPOOFING via SPECIAL CHARS ({pwn_dict[char]}) and NO DKIM has been sent to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', 'X-Mailer' : 'flower'")
                        except smtplib.SMTPResponseException as exc:
                            self.logger.error(f"Error sending email with SPOOFING via SPECIAL CHARS ({pwn_dict[char]}) and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc.smtp_code}` - `{exc.smtp_error}`")
                        except (smtplib.SMTPRecipientsRefused, ConnectionRefusedError, smtplib.SMTPServerDisconnected, smtplib.SMTPConnectError) as exc:
                            self.logger.error(f"Error sending email with SPOOFING via SPECIAL CHARS ({pwn_dict[char]}) and NO DKIM to '{to_addr}' via {ip}:{port}, spoofed 'From': '{from_addr}', err: `{exc}`")

###################################################################################################################


def set_args(args, activate_list):
    for arg in activate_list:
        if getattr(args, arg):
            logging.warning(f"Argument \"{arg}\" has already been activated!")
        setattr(args, arg, True)


def process_args(args):
    SAFE = ["aii", "aci"]
    ALL = SAFE + ["acc", "aicSD", "aicSN", "aicSS", "aicSC", "aicND"]
    if args.safe:
        set_args(args, SAFE)
    elif args.all:
        set_args(args, ALL)


def create_config(args):
    DEFAULT_FILENAME = 'auto-config.yaml'
    if os.path.isfile(DEFAULT_FILENAME):
        logging.warning(f'File {DEFAULT_FILENAME} would be overwritten! Press y to continue...')
        if input().lower().strip() != 'y':
            logging.error('Aborted! No config supplied!')
            exit(1)
    domains = input('Enter domains (comma separated): ')
    mail_servers = input('Enter mail servers (comma separated): ')
    with open(DEFAULT_FILENAME, 'w') as f:
        def adder(arr: List, it: str) -> List:
            d = it.strip()
            if len(d) > 0:
                arr.append(d)
            return arr
        f.write(yaml.dump({
            'DOMAINS': reduce(adder, domains.split(','), []),
            'MAIL_SERVERS': reduce(adder, mail_servers.split(','), []),
        }))
    args.config = DEFAULT_FILENAME

#######################################################################################################################
#######################################################################################################################
#######################################################################################################################
'''
if __name__ == "__main__":

    os.environ['COLUMNS'] = "140"
    argparser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        prog="Check email security.",
        description="This program is designed to completely check all security flaws related to mailing system.\n\n    Easy choice (check mail servers): './prog.py -c config.yaml -o log.txt -d -e -aii -aci -acc -aic'\n\n    Easy choice (check spoofing) (alarm): './prog.py -o config.yaml -o log.txt -aicSD -aicSN -aicSS -aicND'"
    )
    argparser.add_argument("-c", "--config", type=str, metavar="YAML", help="Path to yaml configuration file.")
    argparser.add_argument("-o", "--output", dest="log_file", type=str, default='/dev/null', metavar="DEBUG_OUTPUT_FILE", help="Path to output file (logging will be handled at DEBUG level). (default: '/dev/null')\n\n")

    argparser.add_argument("-d", "--domain", action='store_true', default=False, help="Verify domain security (SPF, DKIM, DMARC). (default: False)")
    argparser.add_argument("-e", "--enum",   action='store_true', default=False, help="Try to enumerate users via SMTP protocol.  (default: False)")
    argparser.add_argument("-6", "--ipv6",   action='store_true', default=False, help="Enable IPv6. (default: False)\n\n")

    argparser.add_argument("-safe", action='store_true', default=False, help="grouped:         Run all safe tests (Default: False)")
    argparser.add_argument("-all",  action='store_true', default=False, help="grouped: (alarm) Run ALL tests.     (Default: False)\n\n")

    argparser.add_argument("-aii", action='store_true', default=False, help="        Try to send email from  Internet (pentester)  -->> to  Internet (pentester).")
    argparser.add_argument("-aci", action='store_true', default=False, help="        Try to send email from          Client        -->> to  Internet (pentester).")
    argparser.add_argument("-acc", action='store_true', default=False, help="(alarm) Try to send email from          Client        -->> to         Client       .")

    argparser.add_argument("-aicSD", action='store_true', default=False, help="(alarm) Try to send email from Internet (pentester) to Client with            Spoofing and    DKIM.")
    argparser.add_argument("-aicSN", action='store_true', default=False, help="(alarm) Try to send email from Internet (pentester) to Client with            Spoofing and No DKIM.")
    argparser.add_argument("-aicSS", action='store_true', default=False, help="(alarm) Try to send email from Internet (pentester) to Client with  Subdomain Spoofing and NO DKIM.")

    argparser.add_argument("-aicSC", action='store_true', default=False, help="(alarm) Try to send email from Internet (pentester) to Client with Special Chars in Subdomain and NO DKIM.")

    argparser.add_argument("-aicND", action='store_true', default=False, help="(alarm) Try to send email from Internet (pentester) to Client with  Partial   Spoofing and    DKIM.")
    argparser.add_argument("-aic-lang", type=str, default="ru", choices=["en", "ru"], help="Language for emails sent to Client (applicable only to aicc, aicXX checks) (default: ru).")

    args = argparser.parse_args()
    process_args(args)
    if args.config is None:
        create_config(args)

    logger = MXServerTester_setup_logger(args.log_file, MXServers.LOGGER_NAME)
    logger = MXServerTester_setup_logger(args.log_file, MXServerTester.LOGGER_NAME)
    logger.critical("This script assumes, that there was no malicious activity from your IP-address and therefore your reputation before client's mail/spam systems is clean. Be careful.")
    try:
        mxTesterModes = MXTesterModes(args.aic_lang, args.aii, args.aci, args.acc, args.aicSD, args.aicSN, args.aicND, args.aicSS, args.aicSC)
        mxServerTester = MXServerTester(args.config, mxTesterModes, args.ipv6)
        if args.domain:
            mxServerTester.check_domain_configurations()
        if args.enum:
            mxServerTester.smtp_enum_check()
        if any([mxTesterModes.aii, mxTesterModes.aci, mxTesterModes.acc]):
            mxServerTester.test_email_relays()
        if any([mxTesterModes.aicSD, mxTesterModes.aicSN, mxTesterModes.aicND, mxTesterModes.aicSS, mxTesterModes.aicSC]):
            mxServerTester.test_email_spoofing()

    except KeyboardInterrupt:
        logger.error("Ctrl+C pressed. Not all check has been produced. Exiting.")
    except Exception as exc:
        logger.critical(f"Unexpected error. Not all check has been produced. Exception: {exc}")
        raise exc

    logger.debug("Bye")
    '''
