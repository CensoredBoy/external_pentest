import socket

import logging
from collections import namedtuple
from collections.abc import Iterable, Sequence
from ipaddress import ip_address
from contextlib import closing

import dns.resolver

#######################################################################################################################
MX_Server = namedtuple('MX_Server', ['name', 'ip', 'port'])

#######################################################################################################################
class MXServers(Sequence, Iterable):

    LOGGER_NAME = "MXServers"
    __socket_scan_timeout = 5

    def __init__(self, domains, servers, ipv6):
        self.logger = logging.getLogger(MXServers.LOGGER_NAME)

        self.ipv6 = ipv6
        self.mx_servers = []

        if not not servers:
            self._parse_servers_into_mx_servers(servers)
        if not not domains:
            self._parse_domains_into_mx_servers(domains)
        self._check_mx_servers_connection()

        if not self.mx_servers:
            raise Exception("No mail servers for analysis discovered, bye.")

        self.logger.debug("List of discovered MX servers:")
        for name, ip, port in self.mx_servers:
            self.logger.info(f"Server for test: {str(name):<20} - {ip.compressed:<15}:{port:<4}")

    ###################################################################################################################
    def __len__(self):
        return len(self.mx_servers)

    def __getitem__(self, index):
        return self.mx_servers[index]

    def __iter__(self):
        for server in self.mx_servers:
            yield server

    ###################################################################################################################
    def _parse_servers_into_mx_servers(self, servers):
        self.logger.debug("Parsing user specified MX servers.")

        for mail_server in servers:
            if mail_server.find(':') != -1:
                server_name, port = mail_server.split(':')[:2]
            else:
                server_name = mail_server
                port = None

            try:
                ip = ip_address(server_name)
                if (ip, port) not in map(lambda tup: (tup.ip, tup.port), self.mx_servers): # check if ip:port is uniq
                    self.mx_servers.append(MX_Server(None, ip, port))
            except ValueError as exc:
                # server_name is not an IP address
                a_records = dns.resolver.query(mail_server, rdtype="A", raise_on_no_answer=False)
                aaaa_records = dns.resolver.query(mail_server, rdtype="AAAA", raise_on_no_answer=False) if self.ipv6 else []
                if not list(a_records) + list(aaaa_records):
                    self.logger.warning(f"DNS name {mail_server} can not be resolved into IP address.")
                for record in list(a_records) + list(aaaa_records):
                    ip = ip_address(record.address)
                    if (ip, port) not in map(lambda tup: (tup.ip, tup.port), self.mx_servers): # check if ip:port is uniq
                        self.logger.info(f"DNS name has been resolved: {mail_server} - {record.address}")
                        self.mx_servers.append(MX_Server(mail_server, ip, port))

    ###################################################################################################################
    def _parse_domains_into_mx_servers(self, domains):
        self.logger.debug("Quering MX servers and their A/AAAA records.")

        ### search mail server in domains written by user
        if domains is not None:
            for domain in domains:

                mx_records = dns.resolver.query(domain, rdtype="MX", raise_on_no_answer=False)
                if not list(mx_records):
                    self.logger.warning(f"Error finding MX servers for domain '{domain}'")
                for mx_record in mx_records:
                    a_records = dns.resolver.query(mx_record.exchange, rdtype="A", raise_on_no_answer=False)
                    aaaa_records = dns.resolver.query(mx_record.exchange, rdtype="AAAA", raise_on_no_answer=False) if self.ipv6 else []
                    if not list(a_records) + list(aaaa_records):
                        self.logger.warning(f"MX server dns name '{mx_record.exchange}' can not be resolved into IP address.")
                    for record in list(a_records) + list(aaaa_records):
                        ip = ip_address(record.address)
                        self.logger.info(f"{domain} - {mx_record.exchange.to_text()[:-1]:<30} - {record.address:<15}")
                        if (ip, None) not in map(lambda tup: (tup.ip, tup.port), self.mx_servers): # check if ip:port is uniq
                            self.mx_servers.append(MX_Server(mx_record.exchange.to_text()[:-1], ip, None))

    ###################################################################################################################
    def _check_mx_servers_connection(self):

        self.logger.debug("Checking TCP ports availability for every MX server.")
        socket.setdefaulttimeout(MXServers.__socket_scan_timeout)

        servers_check_queue = []
        for mail_server in self.mx_servers:
            if mail_server.port is not None:
                servers_check_queue.append(mail_server)
            else:
                # if for server port has not been specified, therefore try each traditional for smtp port
                for port in [25, 2525, 587, 465]:
                    servers_check_queue.append((mail_server.name, mail_server.ip, port))

        self.mx_servers = []
        for name, ip, port in servers_check_queue:

            socket_version = socket.AF_INET if ip.version == 4 else socket.AF_INET6
            with closing(socket.socket(socket_version, socket.SOCK_STREAM)) as sock:

                if sock.connect_ex((ip.compressed, int(port))) == 0:
                    self.mx_servers.append((name, ip, port))
                    self.logger.info(f"Testing mail servers availability: {ip.compressed:<15}:{port:<4} available")
                else:
                    self.logger.warning(f"Testing mail servers availability: {ip.compressed:<15}:{port:<4} UNAVAILABLE")

        socket.setdefaulttimeout(None)
