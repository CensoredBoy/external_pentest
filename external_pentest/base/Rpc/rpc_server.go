package main


import (
        "context"
        "log"
        "time"
        "io"
        "bytes"
        "os"

        amqp "github.com/rabbitmq/amqp091-go"
        "github.com/projectdiscovery/subfinder/v2/pkg/resolve"
        "github.com/projectdiscovery/subfinder/v2/pkg/runner"
)

func failOnError(err error, msg string) {
        if err != nil {
                log.Panicf("%s: %s", msg, err)
        }
}

func fib(n int) int {
        if n == 0 {
                return 0
        } else if n == 1 {
                return 1
        } else {
                return fib(n-1) + fib(n-2)
        }
}

var runnerInstance, err = runner.NewRunner(&runner.Options{
                Threads:            10,                       // Thread controls the number of threads to use for active enumerations
                Timeout:            30,                       // Timeout is the seconds to wait for sources to respond
                MaxEnumerationTime: 10,                       // MaxEnumerationTime is the maximum amount of time in mins to wait for enumeration
                Resolvers:          resolve.DefaultResolvers, // Use the default list of resolvers by marshaling it to the config
                ResultCallback: func(s *resolve.HostEntry) {  // Callback function to execute for available host
                        log.Println(s.Host, s.Source)
                },
        })


func searchingSubDomen(s string) []byte{
        buf := bytes.Buffer{}
        err = runnerInstance.EnumerateSingleDomain(s, []io.Writer{&buf})
        if err != nil {
                log.Fatal(err)
        }

        data, err := io.ReadAll(&buf)
        if err != nil {
                log.Fatal(err)
        }
        return data
}

func main() {
        conn, err := amqp.Dial("amqp://"+os.Getenv("RABBITMQ_USER")+":"+os.Getenv("RABBITMQ_PASSWORD")+"@"+os.Getenv("RABBITMQ_HOST")+":"+os.Getenv("RABBITMQ_PORT")+"/")
        failOnError(err, "Failed to connect to RabbitMQ")
        defer conn.Close()

        ch, err := conn.Channel()
        failOnError(err, "Failed to open a channel")
        defer ch.Close()

        q, err := ch.QueueDeclare(
                "rpc_queue", // name
                false,       // durable
                false,       // delete when unused
                false,       // exclusive
                false,       // no-wait
                nil,         // arguments
        )
        failOnError(err, "Failed to declare a queue")

        err = ch.Qos(
                1,     // prefetch count
                0,     // prefetch size
                false, // global
        )
        failOnError(err, "Failed to set QoS")

        msgs, err := ch.Consume(
                q.Name, // queue
                "",     // consumer
                false,  // auto-ack
                false,  // exclusive
                false,  // no-local
                false,  // no-wait
                nil,    // args
        )
        failOnError(err, "Failed to register a consumer")

        var forever chan struct{}

        go func() {
                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()
                for d := range msgs {
                        domen  := string(d.Body)
                        //failOnError(err, "Failed to convert body to integer")

                        log.Printf(" [.] domen(%s)", domen)

                        response := searchingSubDomen(domen)

                        err = ch.PublishWithContext(ctx,
                                "",        // exchange
                                d.ReplyTo, // routing key
                                false,     // mandatory
                                false,     // immediate
                                amqp.Publishing{
                                        ContentType:   "text/plain",
                                        CorrelationId: d.CorrelationId,
                                        Body:          []byte(response),
                                })
                        failOnError(err, "Failed to publish a message")

                        d.Ack(false)
                }
        }()

        log.Printf(" [*] Awaiting RPC requests")
        <-forever
}
